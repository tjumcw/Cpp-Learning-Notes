# C++ 2.0新标准（11，14）

### Variadic Templates

- 数量不定的模板参数（参数个数随意，每个参数的类型也随意），使用手法：分为1个和剩下的1包

- #### 使用在函数模板上

- ```c++
  void print(){
      //空函数实现，即递归调用到最后一个分为1个和剩下的0个，0个再递归需要有1个终止的空函数
  }
  template<typename T, typename... types>
  void print(const T& firstArg, const Types&... args){
      cout << firstArg << endl;			//打印第一个参数
      print(args...);						//调用print()，其参数为除去第一个参数剩下的一包
  }
  ```

- 如果调用方式为：

- ```c++
  print(7.5, "hello", bitset<16>(377), 42);	//任意个数，任意类型
  ```

- 每次调用该模板函数都会将参数分为一个T和剩下的一包参数作为types，打印出一个后，对剩下的args递归调用

- 一包的部分可以为0个，执行到只有一个参数时，则T为哪一个参数，types为空，打印完T后会调用空的print()，即最上方特意写出来的终止函数（非模板）

- 上述调用的执行结果为：

- ```c++
  7.5
  hello
  0000000101111001
  42
  ```

- 使用Variadic Templates时，一定会需要设计一个终止的边界函数

- #### 使用在类模板上（tuple）

- 回顾之前的STL里面的tuple实现，思想一致，主要就是：

- ```c++
  template<typename... Values> class tuple;				//用以继承的基类
  template<typename... Head, typename... Tail>
  class tuple<Head, Tail...> : private tuple<Tail...>		//内部构造函数将参数分为1个和1包，并递归调用1包的直接基类构造函数
  ```

- 也需要写出一个中止条件，即1个空的模板类

- ```c++
  template<> class<> tuple;
  ```

- 具体实现细节看之前整理的STL的部分



### 一致性初始化

- 使用{}可以进行所有的初始化操作，本质是：
  - 编译器看到{t1, t2, ..., tn}便会做出一个initializer_list<T>，它关联至一个array<T, n>
  - 调用函数时（例如ctor）该array内的元素会被编译器分解逐一传给函数
  - 但若函数参数本身是initializer_list<T>时，不会发生上述事情

- 使用{}初始化时的一些细节

- ```c++
  int i;		//i has undefined value
  int j{};	//j is initialized by 0
  int* p;		//p has undefined value
  int* q{};	//q is initialized by nullptr
  ```

- 与之前的初始化方式的不同，即{}不支持类型的窄化

- ```c++
  int x1(5.3);	//OK, x1 = 5;
  int x2{5.0};	//error/warning，根据不同编译器
  ```



### Initializer_list<>

- 若其作为函数的参数，支持参数个数不定（但类型必须一致，即模板参数），如：

- ```c++
  void print(initializer_list<int> vals){
      for(auto p = vals.begin(); p != vals.end(); ++p){
          std::cout << *p << "\n";
      }
  }
  print({12, 3, 5, 7, 11, 13, 17});		//支持这种形式的参数传入
  ```

- 其类的具体实现的关键细节如下：

- ```c++
  template<class _E>
  class initializer_list{
  public:
      typedef size_t size_type;
      typedef const _E* iterator;		//即模板参数的指针形式就是迭代器类型
  private:
      ierator _M_array;
      size_type _M_len;
      initializer_list(const_iterator __a, size_type __l) : _M_array(__a), _M_len(__l){}	//编译器能调用私有的ctor
  }
  ```

- 编译器在调用私有构造函数之前已经准备好一个array，将其头部的迭代器以及array长度传到构造函数，并登记起来

- 利用Initializer_list可以使用max和min的优化版本

- ```c++
  cout << max({54, 16, 48, 5});	//54
  ```



### explicit

- 禁止编译器隐式调用构造函数（不能自动转换类型以匹配构造函数）

![image](https://user-images.githubusercontent.com/106053649/177334438-35e097db-bff3-4c36-8f9c-5b8e7491da63.png)

- 上图的例子是C++11之前就有的（当时该关键字只支持1个参数的构造函数，第二个有默认就不算），C++11之后支持任意多个参数
- 上图左编译器会去找能否满足编译通过的条件，发现5可以通过Complex的构造函数转化为Complex类型，通过构造函数做了隐式类型转换
- 上图右加了explicit关键字，禁止编译器隐式调用构造函数的行为，故产生了图中的error
