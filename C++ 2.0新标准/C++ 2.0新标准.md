# C++ 2.0新标准（11，14）

### Variadic Templates

- 数量不定的模板参数（参数个数随意，每个参数的类型也随意），使用手法：分为1个和剩下的1包

- #### 使用在函数模板上

- ```c++
  void print(){
      //空函数实现，即递归调用到最后一个分为1个和剩下的0个，0个再递归需要有1个终止的空函数
  }
  template<typename T, typename... types>
  void print(const T& firstArg, const Types&... args){
      cout << firstArg << endl;			//打印第一个参数
      print(args...);						//调用print()，其参数为除去第一个参数剩下的一包
  }
  ```

- 如果调用方式为：

- ```c++
  print(7.5, "hello", bitset<16>(377), 42);	//任意个数，任意类型
  ```

- 每次调用该模板函数都会将参数分为一个T和剩下的一包参数作为types，打印出一个后，对剩下的args递归调用

- 一包的部分可以为0个，执行到只有一个参数时，则T为哪一个参数，types为空，打印完T后会调用空的print()，即最上方特意写出来的终止函数（非模板）

- 上述调用的执行结果为：

- ```c++
  7.5
  hello
  0000000101111001
  42
  ```

- 使用Variadic Templates时，一定会需要设计一个终止的边界函数

- #### 使用在类模板上（tuple）

- 回顾之前的STL里面的tuple实现，思想一致，主要就是：

- ```c++
  template<typename... Values> class tuple;				//用以继承的基类
  template<typename... Head, typename... Tail>
  class tuple<Head, Tail...> : private tuple<Tail...>		//内部构造函数将参数分为1个和1包，并递归调用1包的直接基类构造函数
  ```

- 也需要写出一个中止条件，即1个空的模板类

- ```c++
  template<> class<> tuple;
  ```

- 具体实现细节看之前整理的STL的部分



### 一致性初始化

- 使用{}可以进行所有的初始化操作，本质是：
  - 编译器看到{t1, t2, ..., tn}便会做出一个initializer_list<T>，它关联至一个array<T, n>
  - 调用函数时（例如ctor）该array内的元素会被编译器分解逐一传给函数
  - 但若函数参数本身是initializer_list<T>时，不会发生上述事情

- 使用{}初始化时的一些细节

- ```c++
  int i;		//i has undefined value
  int j{};	//j is initialized by 0
  int* p;		//p has undefined value
  int* q{};	//q is initialized by nullptr
  ```

- 与之前的初始化方式的不同，即{}不支持类型的窄化

- ```c++
  int x1(5.3);	//OK, x1 = 5;
  int x2{5.0};	//error/warning，根据不同编译器
  ```



### Initializer_list<>

- 若其作为函数的参数，支持参数个数不定（但类型必须一致，即模板参数），如：

- ```c++
  void print(initializer_list<int> vals){
      for(auto p = vals.begin(); p != vals.end(); ++p){
          std::cout << *p << "\n";
      }
  }
  print({12, 3, 5, 7, 11, 13, 17});		//支持这种形式的参数传入
  ```

- 其类的具体实现的关键细节如下：

- ```c++
  template<class _E>
  class initializer_list{
  public:
      typedef size_t size_type;
      typedef const _E* iterator;		//即模板参数的指针形式就是迭代器类型
  private:
      ierator _M_array;
      size_type _M_len;
      initializer_list(const_iterator __a, size_type __l) : _M_array(__a), _M_len(__l){}	//编译器能调用私有的ctor
  }
  ```

- 编译器在调用私有构造函数之前已经准备好一个array，将其头部的迭代器以及array长度传到构造函数，并登记起来

- 利用Initializer_list可以使用max和min的优化版本

- ```c++
  cout << max({54, 16, 48, 5});	//54
  ```



### explicit

- 禁止编译器隐式调用构造函数（不能自动转换类型以匹配构造函数）

![image](https://user-images.githubusercontent.com/106053649/177350104-95f9b921-a3c4-4618-bb1c-daa3aeaf7482.png)

- 上图的例子是C++11之前就有的（当时该关键字只支持1个参数的构造函数，第二个有默认就不算），C++11之后支持任意多个参数
- 上图左编译器会去找能否满足编译通过的条件，发现5可以通过Complex的构造函数转化为Complex类型，通过构造函数做了隐式类型转换
- 上图右加了explicit关键字，禁止编译器隐式调用构造函数的行为，故产生了图中的error



### =default，=delete

- 如果自己定义了构造函数（包括3种构造，普通，拷贝，移动），编译器就不会给一个默认的版本
- 如果加上=default（在那3种构造函数声明后面），就可以重新得到一个默认版本（即使已经定义了，还是要编译器给的那一个）
- 默认构造函数（3种）在单一class中没什么用，但若涉及到继承，需要在子类的构造函数中调用父类构造函数，就很有用了 

- 如果加上=delete（在那3种构造函数声明后面），表示不要编译器给的默认版本
- =default用于构造函数和析构函数，=delete不仅如此，还支持其他任何函数
- 通过将一些构造函数=delete，可以实现一些NoCopy，NoDtor等类设计



### Alias Template（template typedef）

- ```c++
  template<typename T>
  using Vec = std::vector<T, MyAlloc<T>>;
  
  Vec<int> coll  ->	std::vector<nt, MyAlloc<int>> coll;			//左边等同于右边
  
  //使用宏来定义完全牛头不对马嘴
  #define Vec<T> template<typename T> std::vector<T, MyAlloc<T>>;
  Vec<int> coll  ->  template<typename int> std::vector<int, MyAlloc<int>> coll;
  
  //若使用typedef，则参数就被绑定死了，没法随意指定模板参数(typedef不接受参数)
  typedef std::vector<int, MyAlloc<int>> Vec
  ```

- 若要对类模板进行特化，则不能对别名特化，需要对原始版本特化



### Type Alias（类似于typedef）

- ```c++
  typedef void(*func)(int, int);		//表示func是一个函数指针，返回值是void，参数是两个int变量
  using func = void(*)(int, int);		//意义同上相同，但更能凸显func是一个类型的事实
  
  void example(int, int){}
  func fn = example;			//func表示为类型，故创建一个对象fn，让其等于example(函数名就是函数地址),通过(*fn)(int, int)即可调用
  ```



### noexcept

- ```c++
  void foo() noexcept;	//表示该函数不会抛出异常
  ```

- 事实上还可以再加一些条件，如：

- ```c++
  void foo() noexcept(true);	//表示符合()内的条件时才不丢出异常,写为true则必然不丢出异常(可以自己写满足的条件)
  ```



### override

- 用在虚函数上，子类重写父类虚函数最好加上override（防止意外写错，如写错参数类型，这样相当于定义了另一个函数但编译器不知道）

- 用法格式如下：

- ```c++
  class Ibase{
  public:
      virtual void vfunc(float){}
      virtual ~Ibase(){}
  };
  
  class Child : public Ibase{
  public:
      virtual void vfunc(float) override{
          //...
      }
  };
  ```



### final

- 如果用在类上，表示其不能在被继承

- ```c++
  class Base final{};
  class Child : public Base{};		//会报错
  ```

- 如果用在虚函数上，表示其不能再被重写

- ```c++
  class Base{
      virtual void f() final;
      virtual ~Base(){}
  };
  
  class Child : public Base{
      void f(){
          //...						//会报错
      }
  };
  ```

